#!/bin/bash

set -e -u

declare -r version=1

export LOCALVERSION="-GracefulLinux"

# 常用变量
work_dir=$(dirname $(realpath -- $0))

quiet=n
append_date=$(date "+%Y%m%d")
app_name="linux-config"
_f_config="$work_dir/config"
_f_kernel_source="/data/source/kernel"
out_dir="${work_dir}/out/${append_date}"

systemmap="$out_dir/System.map"
grub_config="/boot/grub/grub.cfg"

# 会改变的值
kernel_version=""
kernel_name="vmlinux-${kernel_version}-$(uname -m)-${append_date}"
initramfs_name="initramfs-${kernel_version}-$(uname -m)-${append_date}.img"
module="$out_dir/lib/modules/${kernel_version}"
kernel="$out_dir/${kernel_name}"
initramfs="$out_dir/${initramfs_name}"


# 输出信息
_msg_info() 
{
    local _msg="${1}"
    if [[ ${app_name} == '' ]]; then
        [[ "${quiet}" == "y" ]] || printf '\033[32m信息: %s\033[0m\n' "${_msg}" | sed ':label;N;s/\n/ /g;b label' | sed 's/[ ][ ]*/ /g'
    else
        [[ "${quiet}" == "y" ]] || printf '\033[32m[%s] 信息: %s\033[0m\n' "${app_name}" "${_msg}" | sed ':label;N;s/\n/ /g;b label' | sed 's/[ ][ ]*/ /g'
    fi
}

# 输出信息
_msg_info_pure() 
{
    local _msg="${1}"
    printf '\033[32m%s\033[0m\n' "${_msg}" 
}

# 输出警告
_msg_warning()
{
    local _msg="${1}"
    if [[ ${app_name} == '' ]]; then
        printf '\033[33m警告: %s\033[0m\n' "${_msg}" >&2
    else
        printf '\033[33m[%s] 警告: %s\033[0m\n' "${app_name}" "${_msg}" >&2
    fi
}

# 输出错误
_msg_error()
{
    local _msg="${1}"
    local _error="${2}"
    if [[ ${app_name} == '' ]]; then
        printf '\033[31m错误: %s\033[0m\n' "${_msg}" >&2
    else
        printf '\033[31m[%s] 错误: %s\033[0m\n' "${app_name}" "${_msg}" >&2
    fi

    if (( _error != 0 )); then
        exit "${_error}"
    fi
}

# 开始内核编译
build_kernel()
{
    cd "${_f_kernel_source}"

    # 先同步最先代码
    # 自己仓库主分支默认为 'master'
    # 上游取名为 'linux' 
    if [ ! -d "$out_dir" ]; then
        mkdir -p "$out_dir"
        if [ -d "$_f_kernel_source/.git" ]; then
            git fetch --all
            git checkout master
            git merge linux/master
            git push
        fi
    fi

    # 开始清除上次编译的结果
    #make mrproper

    # 开始编译内核
    make bzImage -j32

    # 复制编译成功的文件
    if [ -f "$PWD/vmlinux" ]; then
        _msg_info "内核编译成功!"
        cp System.map   "$systemmap"
        cp vmlinux      "$kernel"
    else
        _msg_error "内核编译失败!" -1
    fi

    # 开始编译内核模块
    export INSTALL_MOD_STRIP=1
    export INSTALL_MOD_PATH="$out_dir"
    _msg_info "make -j32 modules"
    make -j32 modules

    _msg_info "make -j32 modules_install"
    make -j32 modules_install

    cd "$OLDPWD"
}

gen_initramfs()
{
    if [ ! -f "$kernel" ]; then
        _msg_error "内核文件 '$kernel' 没有正确生成" -1
    fi

    _msg_info "mkinitcpio -r ${out_dir} -k ${kernel_version} -g ${initramfs}"
    mkinitcpio -r "${out_dir}" -k "${kernel_version}" -g "${initramfs}"
}

# 解析参数
parseopts() 
{
    local opt= optarg= i= shortopts=$1
    local -a longopts=() unused_argv=()

    shift
    while [[ $1 && $1 != '--' ]]; do
        longopts+=("$1")
        shift
    done
    shift

    longoptmatch() {
        local o longmatch=()
        for o in "${longopts[@]}"; do
            if [[ ${o%:} = "$1" ]]; then
                longmatch=("$o")
                break
            fi
            [[ ${o%:} = "$1"* ]] && longmatch+=("$o")
        done

        case ${#longmatch[*]} in
            1)
                # success, override with opt and return arg req (0 == none, 1 == required)
                opt=${longmatch%:}
                if [[ $longmatch = *: ]]; then
                    return 1
                else
                    return 0
                fi ;;
            0)
                # fail, no match found
                return 255 ;;
            *)
                # fail, ambiguous match
                printf "%s: option '%s' is ambiguous; possibilities:%s\n" "${0##*/}" \
                    "--$1" "$(printf " '%s'" "${longmatch[@]%:}")"
                return 254 ;;
        esac
    }

    while (( $# )); do
        case $1 in
            --) # explicit end of options
                shift
                break
                ;;
            -[!-]*) # short option
                for (( i = 1; i < ${#1}; i++ )); do
                    opt=${1:i:1}

                    # option doesn't exist
                    if [[ $shortopts != *$opt* ]]; then
                        printf "%s: 参数不合法 -- '%s'\n" "${0##*/}" "$opt"
                        OPTRET=(--)
                        return 1
                    fi

                    OPTRET+=("-$opt")
                    # option requires optarg
                    if [[ $shortopts = *$opt:* ]]; then
                        # if we're not at the end of the option chunk, the rest is the optarg
                        if (( i < ${#1} - 1 )); then
                            OPTRET+=("${1:i+1}")
                            break
                        # if we're at the end, grab the the next positional, if it exists
                        elif (( i == ${#1} - 1 )) && [[ "$2" ]]; then
                            OPTRET+=("$2")
                            shift
                            break
                        # parse failure
                        else
                            printf "%s: 配置选项 '%s' 需要一个参数\n" "${0##*/}" "-$opt"
                            OPTRET=(--)
                            return 1
                        fi
                    fi
                done
                ;;
            --?*=*|--?*) # long option
                IFS='=' read -r opt optarg <<< "${1#--}"
                longoptmatch "$opt"
                case $? in
                    0)
                        if [[ $optarg ]]; then
                            printf "%s: 配置选项 '--%s' 无需任何参数\n" "${0##*/}" "$opt"
                            OPTRET=(--)
                            return 1
                        else
                            OPTRET+=("--$opt")
                        fi
                        ;;
                    1)
                        # --longopt=optarg
                        if [[ $optarg ]]; then
                            OPTRET+=("--$opt" "$optarg")
                        # --longopt optarg
                        elif [[ "$2" ]]; then
                            OPTRET+=("--$opt" "$2" )
                            shift
                        else
                            printf "%s: 配置选项 '--%s' 需要参数!\n" "${0##*/}" "$opt"
                            OPTRET=(--)
                            return 1
                        fi
                        ;;
                    254)
                        # ambiguous option -- error was reported for us by longoptmatch()
                        OPTRET=(--)
                        return 1
                        ;;
                    255)
                        # parse failure
                        printf "%s: 未定义的配置选项 '%s'\n" "${0##*/}" "--$opt"
                        OPTRET=(--)
                        return 1
                        ;;
                esac
                ;;
            *) # non-option arg encountered, add it as a parameter
                unused_argv+=("$1")
                ;;
        esac
        shift
    done

    # add end-of-opt terminator and any leftover positional parameters
    OPTRET+=('--' "${unused_argv[@]}" "$@")
    unset longoptmatch

    return 0
}

# 使用说明
usage() 
{
    cat <<EOF
linux-config 当前版本：v$version
使用: ${0##*/} [配置选项]

  配置选项:
   -c, --config <config>        使用指定的内核编译配置 (默认: $work_dir/config)
   -h, --help                   显示此帮助信息并退出
   -v, --version                显示帮助信息并退出
   -q, --quiet                  显示更少信息（编译过程中的日志打印不输出）
   -k, --kernel <dir>           指定内核源码目录（默认：/data/source/kernel）

EOF
}

# 更新 grub 配置
update_grub()
{
    if [ ! -d "/etc/grub.d" ]; then
        _msg_error "检测到文件夹 /etc/grub.d 不存在!" -1
    fi

    # 添加自定义配置，开机显示 grub 菜单
    sudo cp "${work_dir}/00_header" "/etc/grub.d"
    sudo cp "${work_dir}/11_graceful" "/etc/grub.d"

    # 执行
    if [ -f "/usr/bin/update-grub" ]; then
        sudo update-grub -o "${grub_config}"
    elif [ -f "/usr/bin/grub-mkconfig" ]; then
        sudo grub-mkconfig -o "${grub_config}"
    else
        _msg_error "检测到 grub-mkconfig 或 update-grub 不存在!" -1
    fi
    
}

# 安装内核文件
kernel_install()
{
    # 检查内核文件是否生成
    if [ ! -f "${systemmap}" ]; then 
        _msg_error "没有生成 '${systemmap}'" -1
    fi

    if [ ! -f "${kernel}" ]; then 
        _msg_error "没有生成 '${kernel}'" -1
    fi

    if [ ! -f "${initramfs}" ]; then 
        _msg_error "没有生成 '${initramfs}'" -1
    fi

    if [ ! -f "${grub_config}" ]; then 
        _msg_error "没有生成 '${grub_config}'" -1
    fi

    if [ ! -d "${module}" ]; then
        _msg_error "没有生成 '${module}'" -1
    fi

    # 开始安装
    if [ -f '/boot/System.map' ]; then
        sudo mv '/boot/System.map' '/boot/System.map.old'
    fi
    sudo cp "${systemmap}" '/boot/' 

    if [ -f "/boot/${kernel_name}" ]; then
        sudo rm -f "/boot/${kernel_name}"
    fi
    sudo cp "${kernel}" "/boot/${kernel_name}"

    if [ -f "/boot/${initramfs_name}" ]; then
        sudo rm -f "/boot/${initramfs_name}"
    fi
    sudo cp "${initramfs}" "/boot/${initramfs_name}"

    if [ -f "/usr/lib/modules/${kernel_name}" ]; then
        sudo rm -rf "/usr/lib/modules/${kernel_name}"
    fi
    sudo cp -r "${module}" '/usr/lib/modules/'
}

# 输出版本信息
version() 
{
    cat <<EOF
linux-config 当前版本: v$version
EOF
}

cleanup()
{
    local err=${1:-$?}

    #if [[ $_d_workdir ]]; then
    #    # when _optpreset is set, we're in the main loop, not a worker process
    #    if (( _optsavetree )) && [[ -z ${_optpreset[*]} ]]; then
    #        printf '%s\n' "${!_autodetect_cache[@]}" > "$_d_workdir/autodetect_modules"
    #        msg "build directory saved in %s" "$_d_workdir"
    #    else
    #        rm -rf "$_d_workdir"
    #    fi
    #fi

    exit "$err"
}


trap 'cleanup 130' INT
trap 'cleanup 143' TERM

_opt_short='c:k:o:hvq'
_opt_long=('config:' 'addhooks:' 'kernel:' 'hookdir' : 'hookhelp:' 'grubOutput:' 'help' 'version' 'quiet')

parseopts "$_opt_short" "${_opt_long[@]}" -- "$@" || exit 1
set -- "${OPTRET[@]}"
unset _opt_short _opt_long OPTRET


while :; do
    case $1 in
        -c|--config)
            shift
            _f_config=$1
            ;;
        -q|--quiet)
            quiet=y
            ;;
        -o|--grubOutput)
            grubp="$1"
            if [[ x"$grubp" =~ ^x"/*" ]]; then
                grub_config="$1"
            else
                grub_config="${work_dir}/out/${append_date}/grub.cfg"
            fi
            ;;
        -h|--help)
            usage
            cleanup 0
            ;;
        -v|--version)
            version
            cleanup 0
            ;;
        -k|--kernel)
            shift
            _f_kernel_source=$1
            ;;
        --)
            shift
            break 2
            ;;
    esac
    shift
done

# 检查环境
check_env()
{
    cd "${_f_kernel_source}"

    # 添加指定的配置文件
    cp "$_f_config" "$_f_kernel_source/.config"

    make prepare

    kernel_version=$(make -s 'kernelrelease')
    kernel_name="vmlinux-${kernel_version}-$(uname -m)-${append_date}"
    initramfs_name="initramfs-${kernel_version}-$(uname -m)-${append_date}.img"

    module="$out_dir/lib/modules/${kernel_version}"
    kernel="$out_dir/${kernel_name}"
    initramfs="$out_dir/${initramfs_name}"

    _msg_info_pure "当前信息如下:"
    _msg_info_pure "                   时间戳: ${append_date}"
    _msg_info_pure "                 系统架构: $(uname -m)"
    _msg_info_pure "                 内核版本: ${kernel_version}"
    _msg_info_pure "             当前工作目录: ${work_dir}"
    _msg_info_pure "             内核配置文件: ${_f_config}"
    _msg_info_pure "             内核源码目录: ${_f_kernel_source}"
    _msg_info_pure "             输出结果目录: ${out_dir}"
    _msg_info_pure "             输出内核路径: ${kernel}"
    _msg_info_pure "        输出initramfs路径: ${initramfs}"
    _msg_info_pure "       输出System.map路径: ${systemmap}"
    _msg_info_pure "               mkinitcpio: $(type -p 'mkinitcpio')"
    _msg_info_pure "         输出grub配置路径: ${grub_config}"

    echo -e "\n\n"

    cd $OLDPWD
}




##### main 开始
_msg_info "开始检查脚本运行环境 ..."
check_env

_msg_info "开始编译内核 ..."
build_kernel

_msg_info "开始生成 initramfs ..."
gen_initramfs

_msg_info "接下来的操作需要提权 ..."

_msg_info "将内核文件安装到指定位置 ..."
kernel_install

_msg_info "开始更新 grub 配置文件 ..."
update_grub

##### main 结束


